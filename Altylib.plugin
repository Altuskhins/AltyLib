import argparse
import atexit
import copy
import time
import json
import os
import os.path
import threading
import traceback
import contextlib
import functools
import inspect
import math
import heapq
import itertools
import queue
import uuid
from collections import defaultdict, deque
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from functools import wraps
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Dict,
    Iterable,
    Iterator,
    List,
    Optional,
    Sequence,
    Tuple,
    Union,
)

from PIL import Image

from ui.bulletin import BulletinHelper
from ui.settings import Divider, Header, Switch, Input
from base_plugin import BasePlugin, MethodHook
from android_utils import log as logcat, run_on_ui_thread
from client_utils import get_messages_controller, send_request, get_file_loader, get_last_fragment, run_on_queue
from ui.alert import AlertDialogBuilder

from java import dynamic_proxy, cast
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import Utilities, FileLoader
from com.exteragram.messenger.utils import ChatUtils
from com.exteragram.messenger.plugins import PluginsController
from hook_utils import find_class

# плагин вдохновлен zwylib, но дает больше функций, все функции присутствующие в zwylib присутствуют и в этом плагине

__name__ = "AltyLib"
__description__ = "AltyPlugins library with highly used things"
__icon__ = "AltyPlugIcons/1"
__id__ = "altylib"
__version__ = "1.0.3"
__author__ = "@altyplugins"
__min_version__ = "11.9.1"
__all__ = (
    "add_autoupdater_task", "remove_autoupdater_task", "JsonCacheFile", #autoupdater task management
    "detect_client", "detect_language", #detect client and language of the client
    "hide_my_commands", #hide commands of the plugin from comlist
    "shared_set", "shared_get", "shared_delete", "shared_all", #shared data between plugins
    "get_plugins_dirs", #get plugin locations
    "get_current_activity", "bulletin_info", "bulletin_error", "bulletin_success", #bulletin helpers
    "show_spinner", "hide_spinner", #spinner dialog helpers
    "add_tg_alias", "remove_tg_alias", # custom tg:// scheme aliases
    "get_logs", "clear_logs", # retrieve / clear recent AltyLib log lines
    "events_subscribe", "events_unsubscribe", "events_publish", # event bus
    "register_command", "handle_outgoing_command", "get_registered_commands", # command manager
    "tasks_schedule", "tasks_cancel", "tasks_list", # task scheduler
    "rpc_register", "rpc_call", # intra-plugin RPC
    "SettingsRegistry", "create_settings_registry", "open_settings_screen", # settings DSL
    "send_text", "resolve_peer", "current_dialog", "pick_dialog", # typed controllers helpers
    "HookLifecycle", "HookGroup", "safe_hook", "safe_unhook_all", # hook lifecycle utilities
    "debounce", "throttle", "RateLimiter", "priority_queue_worker", # rate limit utilities
    "md", "split_text", # markdown helpers
    "KVStore", "TTLCache", "store_global", # storage helpers
    "download_media", "save_to_gallery", "with_image", # media helpers
    "snackbar_info", "snackbar_warn", "snackbar_error", "snackbar_undo", "quick_list_pick", "show_bottom_sheet", "copy_to_clipboard", # ui helpers
    "on", # notification observers
    "altylib_cli", "init_plugin_scaffold", "validate_plugin_manifest", # cli helpers
    "CrashReporter", "install_crash_reporter", # diagnostics
    "enable_hot_reload", "reload_current_plugin", # debug helpers
    "features_has", "features_register", "features_clear_cache", # compatibility helpers
    "load_recipe", "list_recipes" # cookbook
)


class Callback1(dynamic_proxy(Utilities.Callback)):
    def __init__(self, fn: Callable[[Any], None]):
        super().__init__()
        self._fn = fn

    def run(self, arg):
        try:
            self._fn(arg)
        except Exception:
            log(f"Error in Callback1: {traceback.format_exc().rstrip()}")


class JsonCacheFile:
    cache_dir_name = os.path.join(os.path.dirname(os.path.realpath(__file__)), "cache")

    def __init__(self, filename: str, default: Any, read_on_init = True):
        self.filename = filename
        self.path = os.path.join(JsonCacheFile.cache_dir_name, filename)
        self.content = copy.copy(default)
        self.default = copy.copy(default)

        os.makedirs(JsonCacheFile.cache_dir_name, exist_ok=True)

        if read_on_init:
            self.read()

    def read(self) -> Any:
        try:
            with open(self.path) as file:
                self.content = json.load(file)
        except (json.JSONDecodeError, FileNotFoundError):
            self.wipe()
            return self.default
        else:
            return self.content

    # noinspection PyTypeChecker
    def write(self):
        try:
            with open(self.path, "w") as file:
                json.dump(self.content, file)
        except PermissionError:
            log(f"Permission denied when writing to {self.path}: {traceback.format_exc().rstrip()}")

    def wipe(self):
        self.content = copy.copy(self.default)
        self.write()


@dataclass
class UpdaterTask:
    plugin_id: str
    channel_id: int
    channel_username: str
    message_id: int


class AutoUpdater:
    def __init__(self):
        self.thread: Optional[threading.Thread] = None
        self.forced_stop = False
        self.tasks: List[UpdaterTask] = []
        self.msg_edited_ts_cache = JsonCacheFile("altylib_au__msg_edited_ts", {})  # plugin_id: edit_timestamp_of_message_with_file

    def run(self):
        self.forced_stop = False

        if self.thread is None:
            self.thread = threading.Thread(target=self.cycle)
            self.thread.daemon = True

        if self.thread.is_alive():
            self.log(f"AutoUpdater (id: {id(self)}) has not been stopped")
            return

        self.thread.start()
        self.log(f"AutoUpdater (id: {id(self)}) has been started")

    def force_stop(self):
        if self.thread is None:
            self.log("Ignoring force_stop(): AutoUpdater thread has not been started")
            return
        self.forced_stop = True

    def cycle(self):
        while not self.forced_stop:
            try:
                self.check_for_updates()

                timer = 0
                while timer < self.get_timeout_time():
                    if self.forced_stop:
                        break

                    time.sleep(1)
                    timer += 1
            except Exception:
                self.log(f"Exception in cycle (id: {id(self)}): {traceback.format_exc().rstrip()}")

        self.thread = None
        self.log(f"Force stopped (id: {id(self)})")

    def check_for_updates(self):
        for task in list(self.tasks):  # iterate copy of self.tasks to prevent RuntimeError
            def get_messages_callback(response, error, task=task):
                if error is not None:
                    log(f"Auto update task of plugin (id: {task.plugin_id}) has invalid message. Removing task")
                    self.remove_task(task)
                    return

                msg = get_message(response.messages, task.message_id)
                if not is_valid_plugin_message(msg):
                    log(f"Auto update task of plugin (id: {task.plugin_id}) has invalid message (invalid/no document attached). Removing task")
                    self.remove_task(task)
                    return

                disable_ts_check = setting_getter("disable_ts_check", DEFAULT_EDIT_TIMESTAMP_CHECK)
                if not disable_ts_check:
                    msg_edited_ts = self.msg_edited_ts_cache.content.get(task.plugin_id)
                    if msg.edit_date == msg_edited_ts:
                        self.log((
                            "The message with plugin attachment has not been updated since the "
                            f"last parse. Skipping plugin (id: {task.plugin_id}) update"
                        ))
                        return

                log(f"Executing auto update of plugin (id: {task.plugin_id})")

                file_loader = get_file_loader()
                document = msg.media.getDocument()
                path = file_loader.getPathToAttach(document, True)

                if path.exists():
                    self.msg_edited_ts_cache.content[task.plugin_id] = msg.edit_date
                    self.msg_edited_ts_cache.write()

                run_on_ui_thread(lambda: download_and_install_plugin(msg))

            get_messages(task.channel_id, task.channel_username, get_messages_callback)

    def is_task_already_present(self, task: UpdaterTask):
        for i in list(self.tasks):
            if i.plugin_id == task.plugin_id:
                return True
        return False

    def add_task(self, task: UpdaterTask):
        if self.is_task_already_present(task):
            self.log(f"Task (id: {task.plugin_id}) is already present")
            return

        self.tasks.append(task)
        self.log(f"Added task (id: {task.plugin_id}) to autoupdater")

    def remove_task(self, task: UpdaterTask):
        if task in self.tasks:
            self.tasks.remove(task)
            self.log(f"Removed task (id: {task.plugin_id}) from autoupdater")
        else:
            self.log(f"Task (id: {task.plugin_id}) is not present in list")

    def remove_task_by_id(self, plugin_id: str):
        for task in self.tasks:
            if plugin_id == task.plugin_id:
                self.tasks.remove(task)
                break
        else:
            self.log(f"Task (id: {plugin_id}) is not present in list")
            return
        self.log(f"Removed task (id: {plugin_id}) from autoupdater")

    @staticmethod
    def log(text):
        log("[PyObject] [AutoUpdater] " + text)

    def get_timeout_time(self) -> int:
        try:
            return int(setting_getter("autoupdate_timeout", DEFAULT_AUTOUPDATE_TIMEOUT))
        except (ValueError, TypeError):
            self.log(f"Exception in cycle (id: {id(self)}): {traceback.format_exc().rstrip()}")
            return int(DEFAULT_AUTOUPDATE_TIMEOUT)


def is_valid_plugin_message(msg):
    if msg is None or msg.media is None:
        return False

    document = msg.media.getDocument()
    if document.attributes.isEmpty() or not document.attributes.get(0).file_name.endswith(".plugin"):
        return False
    return True


def download_and_install_plugin(msg):
    def plugin_install_error(arg):
        if arg is None:
            return
        BulletinHelper.show_error(arg)

    file_loader = get_file_loader()
    plugins_controller = PluginsController.getInstance()
    document = msg.media.getDocument()
    path = file_loader.getPathToAttach(document, True)

    if path.exists():
        log("Installing...")
        plugins_controller.loadPluginFromFile(str(path), Callback1(plugin_install_error))
    else:
        log("Started loading the file...")
        file_loader.loadFile(document, "plugin_update", FileLoader.PRIORITY_NORMAL, 1)


def get_messages(channel_id: int, channel_username: str, callback: Callable):
    def get_message_callback(response, error):
        if error or not response:
            callback(None, error)
            return

        messages = cast(TLRPC.messages_Messages, response)
        callback(messages, None)

    def send():
        send_request(req, get_message_callback)

    def channel_resolve_callback(arg):
        if arg is not None and arg.id == channel_id:
            req.peer = TLRPC.TL_inputPeerChannel()
            req.peer.channel_id = arg.id
            req.peer.access_hash = arg.access_hash
            run_on_ui_thread(send)
            return
        log(f"Failed to resolve a channel (id: {channel_id}; username: {channel_username}). Make sure you have entered the correct data")

    req = TLRPC.TL_messages_getHistory()
    req.peer = get_messages_controller().getInputPeer(channel_id)
    req.offset_id = 0
    req.limit = 50

    if req.peer.access_hash == 0:
        ChatUtils.getInstance().resolveChannel(channel_username, Callback1(channel_resolve_callback))
    else:
        run_on_ui_thread(send)


def get_message(messages, message_id: int) -> Optional[TLRPC.Message]:
    for i in range(messages.size()):
        if messages.get(i).id == message_id:
            return messages.get(i)
    return None


# --- Internal log buffer for AltyLib -------------------------------------------------

_LOG_BUFFER: list = []  # type: ignore[var-annotated]
_MAX_LOG_BUFFER = 500  # keep last N lines


def log(string: str):
    """Write message to Android logcat and store it in an internal buffer."""
    msg = f"{__name__}: {string}"
    logcat(msg)
    try:
        _LOG_BUFFER.append(msg)
        if len(_LOG_BUFFER) > _MAX_LOG_BUFFER:
            _LOG_BUFFER.pop(0)
    except Exception:
        # buffer failures should not break execution
        pass


def get_logs(limit: int = 200) -> str:
    """Return the last *limit* log lines joined with newlines."""
    try:
        slice_start = max(len(_LOG_BUFFER) - limit, 0)
        return "\n".join(_LOG_BUFFER[slice_start:])
    except Exception:
        return ""  # fallback empty if any error


def clear_logs():
    """Erase all buffered log entries."""
    try:
        _LOG_BUFFER.clear()
    except Exception:
        pass


# noinspection PyTypeChecker
def add_autoupdater_task(plugin_id: str, channel_id: int, channel_username: str, message_id: int):
    task = UpdaterTask(plugin_id, channel_id, channel_username, message_id)

    if autoupdater is None:
        logcat("AutoUpdater is not initialized yet, saving task to pending list")
        pending_tasks_cache.content.append(asdict(task))
        pending_tasks_cache.write()
        return

    autoupdater.add_task(task)


# noinspection PyTypeChecker
def remove_autoupdater_task(plugin_id: str):
    if autoupdater is None:
        logcat("AutoUpdater is not initialized yet")
        return

    autoupdater.remove_task_by_id(plugin_id)


# noinspection PyTypeChecker
def cache_all_autoupdater_tasks(wipe: bool):
    if wipe:
        pending_tasks_cache.wipe()

    for task in autoupdater.tasks:
        pending_tasks_cache.content.append(asdict(task))
    pending_tasks_cache.write()


def load_cached_autoupdater_tasks(wipe: bool):
    for task in pending_tasks_cache.content:
        try:
            autoupdater.add_task(UpdaterTask(**task))
        except TypeError:
            pass

    if wipe:
        pending_tasks_cache.wipe()


AUTOUPDATE_CHANNEL_ID = 2549262404
AUTOUPDATE_CHANNEL_USERNAME = "AltyPlugins"
AUTOUPDATE_MESSAGE_ID = 26

DEFAULT_EDIT_TIMESTAMP_CHECK = False
DEFAULT_DISABLE_AUTOUPDATER = False
DEFAULT_AUTOUPDATE_TIMEOUT = str(10 * 60)

setting_getter: Optional[Callable] = None
autoupdater: Optional[AutoUpdater] = None
pending_tasks_cache = JsonCacheFile("altylib_au__pending_tasks_list", [])

HIDDEN_PLUGIN_IDS: set = set()


class AltyLib(BasePlugin):
    def create_settings(self):
        try:
            return [
                Header(text="AutoUpdater"),
                Input(
                    key="autoupdate_timeout",
                    text="Auto update timeout",
                    subtext="Time in seconds between update checks",
                    default=DEFAULT_AUTOUPDATE_TIMEOUT,
                    icon="msg2_autodelete",
                ),
                Switch(
                    key="disable_autoupdate",
                    text="Disable autoupdates",
                    subtext="Auto updater will be disabled",
                    default=DEFAULT_DISABLE_AUTOUPDATER,
                    icon="msg_photo_switch2",
                    on_change=lambda enabled: autoupdater.force_stop() if enabled else run_on_ui_thread(autoupdater.run)
                ),
                Switch(
                    key="disable_ts_check",
                    text="Disable message edit check",
                    subtext="Plugin will be updated even if the file has not been modified",
                    default=DEFAULT_EDIT_TIMESTAMP_CHECK,
                    icon="msg_recent",
                ),
            ]
        except Exception:
            text = (
                f"An exception occurred on {self.__class__.__name__}.create_settings():\n"
                f"{traceback.format_exc().rstrip()}"
            )
            log(text)
            return [Divider(text=text)]

    def on_plugin_load(self):
        global autoupdater, setting_getter
        setting_getter = self.get_setting

        log("Initialising AutoUpdater...")
        autoupdater = AutoUpdater()
        add_autoupdater_task(__id__, AUTOUPDATE_CHANNEL_ID, AUTOUPDATE_CHANNEL_USERNAME, AUTOUPDATE_MESSAGE_ID)

        if not self.get_setting("disable_autoupdate", DEFAULT_DISABLE_AUTOUPDATER):
            log("Adding tasks from cache...")
            load_cached_autoupdater_tasks(wipe=True)
            autoupdater.run()

        log("Loaded")

        # New: hook plugin events and patch Command List plugin
        try:
            PCClass = find_class("com.exteragram.messenger.plugins.PluginsController")
            StringClass = find_class("java.lang.String")
            CallbackClass = find_class("org.telegram.messenger.Utilities$Callback")
            # Hook installation (loadPluginFromFile)
            # Some builds hide reflection APIs; try several fallbacks
            load_method = None
            try:
                load_method = PCClass.getDeclaredMethod("loadPluginFromFile", StringClass, CallbackClass)
            except Exception:
                # Try iterate declared / public methods
                for _fetch in ("getDeclaredMethods", "getMethods"):
                    try:
                        for m in getattr(PCClass, _fetch)():
                            if m.getName() == "loadPluginFromFile" and len(m.getParameterTypes()) == 2:
                                load_method = m
                                break
                        if load_method:
                            break
                    except Exception:
                        pass
            if load_method is not None:
                self.hook_method(load_method, _PluginEventHook())
            else:
                log("Altylib: Could not hook loadPluginFromFile – reflection restricted")
            # Hook enable/disable (setPluginEnabled) – find by name to avoid signature issues across versions
            set_enabled_method = None
            for m in PCClass.getDeclaredMethods():
                if m.getName() == "setPluginEnabled":
                    set_enabled_method = m
                    break
            if set_enabled_method is not None:
                self.hook_method(set_enabled_method, _PluginEventHook())
            log("Altylib: Hooked PluginsController methods for plugin events")
        except Exception:
            log(f"Altylib: Failed to hook PluginsController methods: {traceback.format_exc().rstrip()}")

        # Hide ALTYLIB commands from Command List plugin
        try:
            _patch_comlist_plugin()
        except Exception:
            log(f"Altylib: ComList patch error: {traceback.format_exc().rstrip()}")

        # Ensure TG alias hook is installed even if no aliases are registered yet
        try:
            _ensure_tg_hook(self)
        except Exception:
            log(f"Altylib: TG hook setup failed in on_plugin_load: {traceback.format_exc().rstrip()}")

    def on_plugin_unload(self):
        log("Caching all tasks to add them again after reloading the plugin")
        cache_all_autoupdater_tasks(wipe=True)

        log("Force-stopping the AutoUpdater")
        autoupdater.force_stop()

        log("Unloaded")


def detect_client() -> str:
    # First, try to inspect Android files dir via ApplicationLoader
    try:
        from org.telegram.messenger import ApplicationLoader  # type: ignore
        base_dir = ApplicationLoader.getFilesDir().getAbsolutePath()
    except Exception:
        base_dir = None

    # Fallback to plugin file location
    if not base_dir:
        try:
            base_dir = os.path.realpath(__file__)
        except Exception:
            base_dir = ""

    # Normalise to lower for substring checks
    low = str(base_dir).lower()
    if "com.exteragram.messenger" in low:
        return "exteragram"
    if "org.telegram.messenger.web" in low or "com.radolyn.ayugram" in low:
        return "ayugram"
    # default
    return "ayugram"


# === Hook helpers (borrowed & simplified from checkpresence.plugin) ===

class _PluginEventHook(MethodHook):
    """Logs plugin installation/enabling/disabling events."""
    def after_hooked_method(self, param):
        try:
            method_name = param.method.getName() if param and param.method else "<unknown>"
            if method_name == "loadPluginFromFile":
                pth = param.args[0] if param and param.args and len(param.args) >= 1 else None
                if isinstance(pth, str):
                    log(f"Plugin loaded from '{pth}' (client: {detect_client()})")
            elif method_name == "setPluginEnabled":
                plugin_id = param.args[0] if param and param.args and len(param.args) >= 1 else None
                enabled = param.args[1] if param and param.args and len(param.args) >= 2 else None
                log(f"Plugin enable state changed: id={plugin_id} enabled={enabled}")
        except Exception:
            log(f"_PluginEventHook error: {traceback.format_exc().rstrip()}")


# === Hide Altylib commands from the Command List plugin ===

def _apply_patch_to_chp(CHP):
    try:
        if not (isinstance(CHP, type)):
            return False
        # Patch legacy _get_all_commands
        if hasattr(CHP, "_get_all_commands"):
            orig_get = CHP._get_all_commands
            if not getattr(orig_get, "_Altylib_hidden", False):
                def _wrapped_get(self, *args, **kwargs):  # type: ignore
                    data = orig_get(self, *args, **kwargs)
                    try:
                        for _k in list(data.keys()):
                            key_low = str(_k).lower()
                            if any(pid in key_low for pid in HIDDEN_PLUGIN_IDS):
                                data.pop(_k, None)
                    except Exception:
                        pass
                    return data
                _wrapped_get._Altylib_hidden = True  # type: ignore
                CHP._get_all_commands = _wrapped_get  # type: ignore
        # Patch secure harvester
        if hasattr(CHP, "_secure_command_harvester"):
            secure_orig = CHP._secure_command_harvester  # type: ignore
            if not getattr(secure_orig, "_Altylib_hidden", False):
                def _wrapped_sec(self, *args, **kwargs):  # type: ignore
                    data = secure_orig(self, *args, **kwargs)
                    try:
                        for _k in list(data.keys()):
                            key_low = str(_k).lower()
                            if any(pid in key_low for pid in HIDDEN_PLUGIN_IDS):
                                data.pop(_k, None)
                    except Exception:
                        pass
                    return data
                _wrapped_sec._Altylib_hidden = True  # type: ignore
                CHP._secure_command_harvester = _wrapped_sec  # type: ignore

        # Update already-created instances so they use wrapped methods as well
        try:
            import plugins_manager as _pm
            for _inst in list(getattr(_pm.PluginsManager, '_plugins', {}).values()):
                if isinstance(_inst, CHP):
                    for attr_name, attr_val in list(_inst.__dict__.items()):
                        if callable(attr_val):
                            func_obj = getattr(attr_val, "__func__", attr_val)
                            if func_obj in (secure_orig, _wrapped_sec):
                                _inst.__dict__[attr_name] = _wrapped_sec.__get__(_inst, CHP)
                            if 'orig_get' in locals() and func_obj in (orig_get, _wrapped_get):
                                _inst.__dict__[attr_name] = _wrapped_get.__get__(_inst, CHP)
        except Exception:
            pass

        return True
    except Exception:
        return False


def _patch_comlist_plugin():
    try:
        import sys
        from base_plugin import BasePlugin
        patched = False
        for _mod in list(sys.modules.values()):
            try:
                if getattr(_mod, "__id__", None) != "command_list_by_mihailkotovski":
                    continue
                CHP = getattr(_mod, "CommandHarvesterPlugin", None)
                if CHP and _apply_patch_to_chp(CHP):
                    patched = True
                    _patch_comlist_filter(CHP)
                    break
            except Exception:
                continue
        if not patched:
            for cls in list(BasePlugin.__subclasses__()):
                if cls.__name__ != "CommandHarvesterPlugin":
                    continue
                if _apply_patch_to_chp(cls):
                    patched = True
                    _patch_comlist_filter(cls)
                    break
    except Exception:
        log(f"Altylib: Failed to patch Command List plugin: {traceback.format_exc().rstrip()}")


def hide_my_commands(plugin_id: Optional[str] = None):
    """Register the given plugin id to have its commands hidden from @comlist.
    If plugin_id is None, attempts to detect the caller's __id__ attribute automatically.
    Usage (in another plugin):
        from Altylib import hide_my_commands
        hide_my_commands()  # will hide commands of that plugin
    """
    import inspect
    global HIDDEN_PLUGIN_IDS
    if plugin_id is None:
        frame = inspect.currentframe()
        if frame is not None and frame.f_back is not None:
            caller_globals = frame.f_back.f_globals
            plugin_id = caller_globals.get("__id__") or caller_globals.get("__name__")
    if plugin_id:
        pid_low = plugin_id.lower()
        is_new = pid_low not in HIDDEN_PLUGIN_IDS
        HIDDEN_PLUGIN_IDS.add(pid_low)
        # Try to also hide by plugin's display name
        try:
            import plugins_manager as _pm
            pl_obj = _pm.PluginsManager._plugins.get(plugin_id)
            if pl_obj and getattr(pl_obj, 'name', None):
                HIDDEN_PLUGIN_IDS.add(str(pl_obj.name).lower())
        except Exception:
            pass
        if is_new:
            log(f"Registered plugin '{plugin_id}' for command hiding (total hidden: {len(HIDDEN_PLUGIN_IDS)})")
        try:
            _patch_comlist_plugin()  # ensure patch applied
        except Exception:
            pass


def detect_language() -> str:
    """Detect current UI language code of the client (e.g. 'en', 'ru').
    Primary method uses Telegram's LocaleController; fallback to Python's locale.
    """
    try:
        from org.telegram.messenger import LocaleController  # type: ignore
        lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        if lang:
            return str(lang)
    except Exception:
        pass
    # Fallback to Python locale
    try:
        import locale as _locale
        loc = _locale.getdefaultlocale()
        if loc and loc[0]:
            return str(loc[0]).split("_")[0]
    except Exception:
        pass
    return "en"


#Cross-plugin Shared Key-Value Store 

_shared_store_lock = threading.Lock()
_shared_store_path = os.path.join(JsonCacheFile.cache_dir_name, "altylib_shared_store.json")

# In-memory cache of shared data
try:
    with open(_shared_store_path, "r", encoding="utf-8") as _ssf:
        _shared_store_cache: dict = json.load(_ssf)
except Exception:
    _shared_store_cache: dict = {}


def _shared_store_flush():
    """Write cache to disk atomically."""
    try:
        tmp_path = _shared_store_path + ".tmp"
        with open(tmp_path, "w", encoding="utf-8") as _tf:
            json.dump(_shared_store_cache, _tf)
        os.replace(tmp_path, _shared_store_path)
    except Exception:
        log(f"SharedStore flush error: {traceback.format_exc().rstrip()}")


def shared_set(key: str, value: Any):
    """Set value for key in the cross-plugin store."""
    with _shared_store_lock:
        _shared_store_cache[key] = value
        _shared_store_flush()


def shared_get(key: str, default: Any = None) -> Any:
    """Retrieve value for key from the shared store (default if missing)."""
    with _shared_store_lock:
        return copy.deepcopy(_shared_store_cache.get(key, default))


def shared_delete(key: str):
    """Remove a key from the store, if present."""
    with _shared_store_lock:
        if key in _shared_store_cache:
            _shared_store_cache.pop(key, None)
            _shared_store_flush()


def shared_all() -> dict:
    """Return a deep copy of the entire shared store."""
    with _shared_store_lock:
        return copy.deepcopy(_shared_store_cache)


# UI Helpers

_spinner_dialog_builder: Optional[AlertDialogBuilder] = None


def get_current_activity():
    """Try to retrieve the current Android activity via last fragment."""
    try:
        frag = get_last_fragment()
        if frag:
            act = frag.getParentActivity()
            if act:
                return act
    except Exception:
        pass
    return None


def _run_ui(fn):
    """Helper: execute fn on UI thread (sync if already on UI thread)."""
    run_on_ui_thread(fn)


# Bulletin wrappers

def bulletin_info(text: str):
    """Show informational bulletin/toast message."""
    log(f"Bulletin_info called: {text}")
    _run_ui(lambda: BulletinHelper.show(text))


def bulletin_error(text: str):
    log(f"Bulletin_error called: {text}")
    _run_ui(lambda: BulletinHelper.show_error(text))


def bulletin_success(text: str):
    # Some builds have BulletinHelper.show_success; fall back to show
    def _impl():
        if hasattr(BulletinHelper, "show_success"):
            log(f"Bulletin_success called: {text}")
            BulletinHelper.show_success(text)  # type: ignore
        else:
            log(f"Bulletin_success called (fallback): {text}")
            BulletinHelper.show(text)
    _run_ui(_impl)


# Spinner dialog

def show_spinner(text: Optional[str] = None):
    """Show modal spinner. Returns builder handle to dismiss later."""
    global _spinner_dialog_builder
    def _impl():
        global _spinner_dialog_builder
        if _spinner_dialog_builder is not None:
            # already shown
            return
        act = get_current_activity()
        if not act:
            return
        builder = AlertDialogBuilder(act, AlertDialogBuilder.ALERT_TYPE_SPINNER)
        builder.set_cancelable(False)
        if text and hasattr(builder, "set_text"):
            try:
                builder.set_text(text)
            except Exception:
                pass
        builder.show()
        _spinner_dialog_builder = builder
    _run_ui(_impl)
    return _spinner_dialog_builder


def hide_spinner():
    global _spinner_dialog_builder
    def _impl():
        global _spinner_dialog_builder
        if _spinner_dialog_builder:
            try:
                _spinner_dialog_builder.dismiss()
            except Exception:
                pass
            _spinner_dialog_builder = None
    _run_ui(_impl)


# === Utility: return list of plugin directories ===

def get_plugins_dirs() -> list:
    """Return a list of directories where plugins may reside for the current client."""
    dirs = []
    # Try to get runtime plugins dir from PluginsManager
    try:
        import plugins_manager as _pm  # type: ignore
        pm = _pm.PluginsManager
        plugin_dir = getattr(pm, '_plugins_dir', None)
        if plugin_dir and plugin_dir not in dirs:
            dirs.append(plugin_dir)
    except Exception:
        pass

    # Known base dirs
    known = [
        "/data/user/0/com.exteragram.messenger/files",
        "/data/user/0/org.telegram.messenger.web/files",
        "/data/user/0/com.radolyn.ayugram/files",
    ]
    for d in known:
        if d not in dirs:
            dirs.append(d)
    return dirs


# Robust retrieval of current module without relying on double-underscore names
import sys as _sys
_module_name = globals().get('__name__') or globals().get('name')
this_module = _sys.modules.get(_module_name)
if this_module is None:
    # Fallback: last inserted module in sys.modules (should be ourselves during import)
    this_module = _sys.modules[list(_sys.modules.keys())[-1]]

for _alias in ("zwylib", "zwyLib", "ZwyLib", "Zwylib", "AltyLib", "Altylib", "altylib"):
    _sys.modules.setdefault(_alias, this_module)

#Additional filter on _format_command_list 

def _patch_comlist_filter(CHP):
    try:
        if hasattr(CHP, "_format_command_list"):
            orig_fmt = CHP._format_command_list
            if getattr(orig_fmt, "_alty_filtered", False):
                return

            def _wrapped_fmt(self, all_commands, __o=orig_fmt):
                try:
                    filtered = {}
                    for k, v in all_commands.items():
                        low = str(k).lower()
                        if low in HIDDEN_PLUGIN_IDS:
                            continue
                        skip = False
                        for pid in HIDDEN_PLUGIN_IDS:
                            if pid in low:
                                skip = True
                                break
                        if not skip:
                            filtered[k] = v
                except Exception:
                    filtered = all_commands
                return __o(self, filtered)

            _wrapped_fmt._alty_filtered = True  # type: ignore
            CHP._format_command_list = _wrapped_fmt  # type: ignore

            # Update instances
            try:
                import plugins_manager as _pm
                for inst in list(getattr(_pm.PluginsManager, '_plugins', {}).values()):
                    if isinstance(inst, CHP):
                        if hasattr(inst, "_format_command_list"):
                            inst._format_command_list = _wrapped_fmt.__get__(inst, CHP)  # type: ignore
            except Exception:
                pass
    except Exception:
        log(f"Altylib: Failed to patch format_command_list: {traceback.format_exc().rstrip()}")

#TG Alias support

_TG_ALIAS_MAP: dict = {}
_tg_hook_installed = False


class _TGIntentHook(MethodHook):
    def before_hooked_method(self, param):
        try:
            if not _TG_ALIAS_MAP:
                return
            if not param.args or len(param.args) < 1:
                return
            intent = param.args[0]
            if intent is None:
                return
            data = intent.getData()
            if data is None:
                return
            url = str(data.toString())
            if not url.startswith("tg://"):
                return
            # Remove 'tg://' prefix and leading '/'
            path = url[5:]
            if path.startswith("/"):
                path = path[1:]
            # Iterate registered aliases
            for alias, cb in list(_TG_ALIAS_MAP.items()):
                if path.startswith(alias):
                    try:
                        run_on_ui_thread(lambda: cb(intent))
                    except Exception as e:
                        log(f"TG alias callback error for '{alias}': {e}")
                    # prevent default processing if possible
                    try:
                        param.setResult(None)
                    except Exception:
                        pass
                    break
        except Exception:
            log(f"_TGIntentHook error: {traceback.format_exc().rstrip()}")


def _ensure_tg_hook(plugin_self):
    global _tg_hook_installed
    if _tg_hook_installed:
        return
    try:
        LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
        IntentClass = find_class("android.content.Intent")
        LAClass = LaunchActivity.getClass() if hasattr(LaunchActivity, "getClass") else LaunchActivity

        # Try to enumerate methods first (preferred for exhaustive hooking)
        _methods = []
        for _fetch in ("getDeclaredMethods", "getMethods"):
            try:
                _methods = list(getattr(LAClass, _fetch)())
                break
            except Exception:
                _methods = []

        if _methods:
            for m in _methods:
                if m.getName() != "handleIntent":
                    continue
                params = m.getParameterTypes()
                if params is None or len(params) == 0:
                    continue
                first = params[0]
                try:
                    if first != IntentClass and first.getName() != "android.content.Intent":
                        continue
                except Exception:
                    if str(first) != str(IntentClass):
                        continue
                plugin_self.hook_method(m, _TGIntentHook())
            _tg_hook_installed = True
            log("Altylib: TG alias hook installed (enumeration)")
            return

        # Enumeration failed – fallback to known signature used in re_extera.plugin
        try:
            from java.lang import Boolean  # type: ignore
            BrowserProgress = find_class("org.telegram.messenger.browser.Browser$Progress")
            method_sig = [IntentClass, Boolean.TYPE, Boolean.TYPE, Boolean.TYPE, BrowserProgress, Boolean.TYPE, Boolean.TYPE]
            try:
                m = LAClass.getDeclaredMethod("handleIntent", *method_sig)
                plugin_self.hook_method(m, _TGIntentHook())
                _tg_hook_installed = True
                log("Altylib: TG alias hook installed (re_extera signature)")
                return
            except Exception:
                pass
        except Exception:
            pass

        log("Altylib: Could not install TG alias hook – reflection restricted")
        _tg_hook_installed = True  # prevent further attempts
    except Exception:
        log(f"Altylib: Failed to install TG alias hook: {traceback.format_exc().rstrip()}")


def add_tg_alias(path: str, callback):
    """Register a custom tg://<path> alias. Example path: 're/augh' (without leading slash).
    Callback receives the original Intent object and runs on UI thread.
    """
    if not isinstance(path, str) or not path:
        raise ValueError("path must be non-empty string")
    _TG_ALIAS_MAP[path] = callback
    try:
        # ensure hook via first loaded AltyLib instance
        import plugins_manager as _pm
        for _pl in _pm.PluginsManager._plugins.values():
            if getattr(_pl, 'id', None) == __id__:
                _ensure_tg_hook(_pl)
                break
    except Exception:
        pass


def remove_tg_alias(path: str):
    _TG_ALIAS_MAP.pop(path, None)


# === Simple Event Bus ==============================================================

_EVENT_LOCK = threading.Lock()
_EVENT_LISTENERS: dict = {}


def events_subscribe(event: str, callback):
    """Subscribe to an event name. Callback receives one argument: data."""
    if not callable(callback):
        raise ValueError("callback must be callable")
    with _EVENT_LOCK:
        _EVENT_LISTENERS.setdefault(event, []).append(callback)


def events_unsubscribe(event: str, callback):
    with _EVENT_LOCK:
        lst = _EVENT_LISTENERS.get(event)
        if lst and callback in lst:
            lst.remove(callback)


def events_publish(event: str, data=None, *, async_call: bool = True):
    """Publish an event to all listeners. If *async_call* is True, callbacks run on background queue."""
    with _EVENT_LOCK:
        listeners = list(_EVENT_LISTENERS.get(event, []))
    log(f"EventBus: publish '{event}' to {len(listeners)} listener(s)")
    if not listeners:
        return
    for cb in listeners:
        try:
            if async_call:
                run_on_queue(lambda cb=cb: cb(data))
            else:
                cb(data)
        except Exception as e:
            log(f"Event '{event}' handler error: {e}")


# Simplified Command Manager 

_CMD_LOCK = threading.Lock()
_COMMANDS: dict = {}


def register_command(name: str, callback, description: str = ""):
    """Register a global text command ('.<name>'). Callback signature: (plugin_self, args_str, params)."""
    if not callable(callback):
        raise ValueError("callback must be callable")
    with _CMD_LOCK:
        _COMMANDS[name.lower()] = {
            "callback": callback,
            "description": description or callback.__doc__ or "",
        }


def get_registered_commands():
    with _CMD_LOCK:
        return {k: v["description"] for k, v in _COMMANDS.items()}


def _call_command(cmd_lower: str, plugin_self, args: str, params):
    entry = _COMMANDS.get(cmd_lower)
    if not entry:
        return None
    cb = entry["callback"]
    try:
        return cb(plugin_self, args, params)
    except Exception as e:
        log(f"Command '{cmd_lower}' error: {e}")
        return f"Error executing command '{cmd_lower}': {e}"


def handle_outgoing_command(plugin_self, account: int, params):
    """Helper for use inside on_send_message_hook.

    If params.message starts with a registered command, executes it and returns HookResult.
    Otherwise returns None and caller should continue processing.
    """
    from base_plugin import HookResult, HookStrategy
    msg = getattr(params, "message", None)
    if not isinstance(msg, str) or not msg.startswith('.'):
        return None
    # split into command and rest
    parts = msg[1:].split(' ', 1)
    cmd = parts[0].lower()
    args = parts[1] if len(parts) > 1 else ""

    result = _call_command(cmd, plugin_self, args, params)
    if result is None:
        # unknown command
        return None

    if isinstance(result, HookResult):
        return result
    if isinstance(result, str):
        params.message = result
    # default: treat as MODIFY
    return HookResult(strategy=HookStrategy.MODIFY, params=params)


# Simple Task Scheduler

_TASK_LOCK = threading.Lock()
_TASKS: dict = {}  # name -> dict(cb, interval, next_ts)
_SCHED_THREAD = None  # type: ignore[var-annotated]


def _scheduler_loop():
    global _SCHED_THREAD
    while True:
        with _TASK_LOCK:
            tasks_snapshot = list(_TASKS.items())
        if not tasks_snapshot:
            break  # no tasks → exit thread
        now = time.time()
        for name, info in tasks_snapshot:
            if now >= info["next_ts"]:
                # schedule execution
                run_on_queue(info["cb"])
                with _TASK_LOCK:
                    # task might have been cancelled while executing
                    if name in _TASKS:
                        _TASKS[name]["next_ts"] = now + info["interval"]
        time.sleep(1)
    _SCHED_THREAD = None


def _ensure_scheduler_running():
    global _SCHED_THREAD
    if _SCHED_THREAD is None or not _SCHED_THREAD.is_alive():
        _SCHED_THREAD = threading.Thread(target=_scheduler_loop, daemon=True)
        _SCHED_THREAD.start()


def tasks_schedule(name: str, callback, interval_seconds: int, *, run_immediately: bool = False):
    """Schedule a periodic task. Name must be unique across plugins."""
    if not callable(callback):
        raise ValueError("callback must be callable")
    with _TASK_LOCK:
        _TASKS[name] = {
            "cb": callback,
            "interval": max(1, int(interval_seconds)),
            "next_ts": time.time() if run_immediately else time.time() + interval_seconds,
        }
    log(f"TaskScheduler: scheduled '{name}' every {interval_seconds}s")
    _ensure_scheduler_running()


def tasks_cancel(name: str):
    with _TASK_LOCK:
        if _TASKS.pop(name, None) is not None:
            log(f"TaskScheduler: cancelled '{name}'")


def tasks_list():
    with _TASK_LOCK:
        return {k: v["interval"] for k, v in _TASKS.items()}


# In-process RPC Registry

_RPC_LOCK = threading.Lock()
_RPC_FUNCS: dict = {}


def rpc_register(name: str, func):
    """Expose a callable under *name* for other plugins."""
    if not callable(func):
        raise ValueError("func must be callable")
    with _RPC_LOCK:
        _RPC_FUNCS[name] = func
    log(f"RPC: registered '{name}'")


def rpc_call(name: str, *args, **kwargs):
    with _RPC_LOCK:
        fn = _RPC_FUNCS.get(name)
    if not fn:
        raise RuntimeError(f"RPC: function '{name}' not found")
    return fn(*args, **kwargs)


# === Persistent Storage Helpers ======================================================


class KVStore:
    """Small JSON-backed key/value store with thread-safety and deepcopy semantics."""

    def __init__(self, name: str, *, default: Optional[dict] = None, autosave: bool = True):
        if not name:
            raise ValueError("name must be provided")
        if name.endswith(".json"):
            filename = name
        else:
            filename = f"{name}.json"
        self._file = JsonCacheFile(filename, default or {})
        self._lock = threading.RLock()
        # copy initial data to avoid accidental mutation
        self._data: Dict[str, Any] = copy.deepcopy(self._file.content)
        self._autosave = autosave

    def _write(self):
        self._file.content = copy.deepcopy(self._data)
        self._file.write()

    def flush(self):
        with self._lock:
            self._write()

    def clear(self):
        with self._lock:
            self._data.clear()
            if self._autosave:
                self._write()

    def get(self, key: str, default: Any = None) -> Any:
        with self._lock:
            return copy.deepcopy(self._data.get(key, default))

    def set(self, key: str, value: Any):
        with self._lock:
            self._data[key] = copy.deepcopy(value)
            if self._autosave:
                self._write()

    def pop(self, key: str, default: Any = None) -> Any:
        with self._lock:
            value = self._data.pop(key, default)
            if self._autosave:
                self._write()
            return copy.deepcopy(value)

    def update(self, mapping: Dict[str, Any]):
        with self._lock:
            for key, value in mapping.items():
                self._data[key] = copy.deepcopy(value)
            if self._autosave:
                self._write()

    def items(self):
        with self._lock:
            return [(k, copy.deepcopy(v)) for k, v in self._data.items()]

    def __getitem__(self, key: str) -> Any:
        with self._lock:
            return copy.deepcopy(self._data[key])

    def __setitem__(self, key: str, value: Any):
        self.set(key, value)

    def __contains__(self, key: str) -> bool:
        with self._lock:
            return key in self._data

    def __len__(self) -> int:
        with self._lock:
            return len(self._data)


class TTLCache:
    """In-memory cache with TTL support and optional size limiting."""

    def __init__(self, *, default_ttl: Optional[float] = None, maxsize: Optional[int] = 256):
        self.default_ttl = default_ttl
        self.maxsize = maxsize
        self._data: Dict[Any, Tuple[Any, Optional[float]]] = {}
        self._expiry_heap: List[Tuple[float, Any]] = []
        self._lock = threading.RLock()

    @staticmethod
    def _now() -> float:
        return time.time()

    def _purge_expired(self):
        if not self._expiry_heap:
            return
        now = self._now()
        while self._expiry_heap and self._expiry_heap[0][0] <= now:
            expiry, key = heapq.heappop(self._expiry_heap)
            entry = self._data.get(key)
            if entry and entry[1] == expiry:
                self._data.pop(key, None)

    def _evict_lru(self):
        if self.maxsize and len(self._data) > self.maxsize:
            # drop the oldest item by expiry heap or arbitrary
            if self._expiry_heap:
                _, key = heapq.heappop(self._expiry_heap)
                self._data.pop(key, None)
            else:
                # fall back to FIFO order
                key = next(iter(self._data.keys()))
                self._data.pop(key, None)

    def set(self, key: Any, value: Any, *, ttl: Optional[float] = None):
        ttl_value = ttl if ttl is not None else self.default_ttl
        expire_at = None
        if ttl_value:
            expire_at = self._now() + float(ttl_value)
        with self._lock:
            self._data[key] = (copy.deepcopy(value), expire_at)
            if expire_at is not None:
                heapq.heappush(self._expiry_heap, (expire_at, key))
            self._evict_lru()

    def get(self, key: Any, default: Any = None) -> Any:
        with self._lock:
            self._purge_expired()
            entry = self._data.get(key)
            if not entry:
                return default
            return copy.deepcopy(entry[0])

    def pop(self, key: Any, default: Any = None) -> Any:
        with self._lock:
            self._purge_expired()
            entry = self._data.pop(key, None)
            if not entry:
                return default
            return copy.deepcopy(entry[0])

    def clear(self):
        with self._lock:
            self._data.clear()
            self._expiry_heap.clear()

    def get_or_set(self, key: Any, loader: Callable[[], Any], *, ttl: Optional[float] = None):
        sentinel = object()
        value = self.get(key, sentinel)
        if value is not sentinel:
            return value
        value = loader()
        self.set(key, value, ttl=ttl)
        return value


store_global = KVStore("altylib_global_store")


# === Settings DSL ===================================================================


@dataclass
class _SettingDefinition:
    key: str
    type: str
    title: str
    summary: Optional[str]
    default: Any
    options: Optional[Sequence[Tuple[str, Any]]] = None
    min_value: Optional[float] = None
    max_value: Optional[float] = None
    step: Optional[float] = None
    callback: Optional[Callable[[Any], None]] = None


class SettingHandle:
    def __init__(self, registry: "SettingsRegistry", definition: _SettingDefinition):
        self._registry = registry
        self.definition = definition

    def get(self, default: Any = None) -> Any:
        return self._registry.get(self.definition.key, default)

    def set(self, value: Any):
        self._registry.set(self.definition.key, value)
        return value

    def toggle(self) -> bool:
        if self.definition.type != "switch":
            raise TypeError("toggle() available only for switch settings")
        value = not bool(self.get())
        self.set(value)
        return value

    @property
    def value(self):
        return self.get()

    @value.setter
    def value(self, val):
        self.set(val)


class SettingsRegistry:
    """Declarative mini-DSL for describing plugin settings."""

    def __init__(self, namespace: str, *, title: Optional[str] = None, store: Optional[KVStore] = None):
        self.namespace = namespace
        self.title = title or namespace
        self.store = store or KVStore(f"settings_{namespace}")
        self._definitions: List[_SettingDefinition] = []
        self._handles: Dict[str, SettingHandle] = {}

    # Decorators -----------------------------------------------------------------

    def switch(
        self,
        key: Optional[str] = None,
        *,
        default: bool = False,
        title: Optional[str] = None,
        summary: Optional[str] = None,
        on_change: Optional[Callable[[bool], None]] = None,
    ):
        def decorator(func: Optional[Callable[[bool], None]] = None):
            setting_key = key or (func.__name__ if func else None)
            if not setting_key:
                raise ValueError("switch decorator requires key or callable with name")
            definition = _SettingDefinition(
                key=setting_key,
                type="switch",
                title=title or setting_key.replace("_", " ").title(),
                summary=summary,
                default=bool(default),
                callback=on_change or func,
            )
            return self._register(definition)

        if callable(key):
            func = key  # type: ignore[assignment]
            key = None
            return decorator(func)

        return decorator

    def list(
        self,
        key: Optional[str] = None,
        *,
        options: Optional[Sequence[Tuple[str, Any]]] = None,
        default: Any = None,
        title: Optional[str] = None,
        summary: Optional[str] = None,
        on_change: Optional[Callable[[Any], None]] = None,
    ):
        def decorator(func: Optional[Callable[[Any], None]] = None):
            setting_key = key or (func.__name__ if func else None)
            if not setting_key:
                raise ValueError("list decorator requires key or callable with name")
            normalized_options: List[Tuple[str, Any]] = []
            if options:
                for opt in options:
                    if isinstance(opt, tuple):
                        normalized_options.append(opt)
                    else:
                        normalized_options.append((str(opt), opt))
            definition = _SettingDefinition(
                key=setting_key,
                type="list",
                title=title or setting_key.replace("_", " ").title(),
                summary=summary,
                default=default,
                options=normalized_options,
                callback=on_change or func,
            )
            return self._register(definition)

        if callable(key):
            func = key  # type: ignore[assignment]
            key = None
            return decorator(func)
        return decorator

    def slider(
        self,
        key: Optional[str] = None,
        *,
        min_value: float = 0.0,
        max_value: float = 1.0,
        step: float = 1.0,
        default: float = 0.0,
        title: Optional[str] = None,
        summary: Optional[str] = None,
        on_change: Optional[Callable[[float], None]] = None,
    ):
        def decorator(func: Optional[Callable[[float], None]] = None):
            setting_key = key or (func.__name__ if func else None)
            if not setting_key:
                raise ValueError("slider decorator requires key or callable with name")
            definition = _SettingDefinition(
                key=setting_key,
                type="slider",
                title=title or setting_key.replace("_", " ").title(),
                summary=summary,
                default=float(default),
                min_value=float(min_value),
                max_value=float(max_value),
                step=float(step) if step else 1.0,
                callback=on_change or func,
            )
            return self._register(definition)

        if callable(key):
            func = key  # type: ignore[assignment]
            key = None
            return decorator(func)
        return decorator

    # Core API -------------------------------------------------------------------

    def _register(self, definition: _SettingDefinition) -> SettingHandle:
        if definition.key in self._handles:
            return self._handles[definition.key]
        if definition.key not in self.store:
            self.store.set(definition.key, copy.deepcopy(definition.default))
        handle = SettingHandle(self, definition)
        self._definitions.append(definition)
        self._handles[definition.key] = handle
        return handle

    def keys(self) -> List[str]:
        return list(self._handles.keys())

    def get(self, key: str, default: Any = None) -> Any:
        if key in self.store:
            return self.store.get(key)
        return default

    def set(self, key: str, value: Any):
        old = self.get(key)
        self.store.set(key, value)
        if old != value:
            handle = self._handles.get(key)
            if handle:
                self._notify(handle.definition, value)

    def as_dict(self) -> Dict[str, Any]:
        return {key: self.get(key) for key in self.keys()}

    def _notify(self, definition: _SettingDefinition, value: Any):
        callback = definition.callback
        if not callback:
            return
        try:
            callback(value)
        except Exception:
            log(f"SettingsRegistry callback for '{definition.key}' failed: {traceback.format_exc().rstrip()}")

    # UI -------------------------------------------------------------------------

    def open(self, *, title: Optional[str] = None):
        open_settings_screen(self, title=title or self.title)


def create_settings_registry(namespace: str, **kwargs) -> SettingsRegistry:
    return SettingsRegistry(namespace, **kwargs)


def _format_setting_value(value: Any) -> str:
    if isinstance(value, bool):
        return "On" if value else "Off"
    if isinstance(value, (int, float)):
        if abs(value) >= 1000:
            return f"{value:,.0f}".replace(",", " ")
        return str(round(value, 2)).rstrip("0").rstrip(".") if isinstance(value, float) else str(value)
    if value is None:
        return "—"
    return str(value)


def open_settings_screen(registry: SettingsRegistry, *, title: Optional[str] = None):
    activity = get_current_activity()
    if activity is None:
        log("SettingsRegistry: cannot open settings without active activity")
        return

    definitions = list(registry._definitions)
    if not definitions:
        bulletin_info("Нет доступных настроек")
        return

    items: List[str] = []
    actions: List[Callable[[], None]] = []

    for definition in definitions:
        value = registry.get(definition.key, definition.default)
        label = f"{definition.title}: {_format_setting_value(value)}"
        if definition.summary:
            label += f"\n{definition.summary}"
        items.append(label)

        if definition.type == "switch":
            def make_switch(defn: _SettingDefinition):
                def action():
                    current = bool(registry.get(defn.key, defn.default))
                    registry.set(defn.key, not current)
                    open_settings_screen(registry, title=title)

                return action

            actions.append(make_switch(definition))
        elif definition.type == "list":
            def make_list(defn: _SettingDefinition):
                def action():
                    options = defn.options or []
                    if not options:
                        bulletin_warn = getattr(BulletinHelper, "show_warning", None)
                        if bulletin_warn:
                            bulletin_warn("Нет вариантов для выбора")
                        return
                    builder = AlertDialogBuilder(activity)
                    builder.setTitle(defn.title)
                    entries = [opt[0] for opt in options]

                    def on_select(index: int):
                        try:
                            value = options[index][1]
                        except IndexError:
                            return
                        registry.set(defn.key, value)

                    builder.setItems(entries, Callback1(on_select))
                    builder.setNegativeButton("Отмена", None)
                    builder.show()

                return action

            actions.append(make_list(definition))
        elif definition.type == "slider":
            def make_slider(defn: _SettingDefinition):
                def action():
                    min_v = defn.min_value if defn.min_value is not None else 0
                    max_v = defn.max_value if defn.max_value is not None else 100
                    step = defn.step or 1
                    current = float(registry.get(defn.key, defn.default))
                    values: List[float] = []
                    if max_v > min_v:
                        steps = int((max_v - min_v) / step) if step else 0
                        if step and steps <= 200:
                            value = min_v
                            while value <= max_v + 1e-9:
                                values.append(round(value, 6))
                                value += step
                        else:
                            # fallback to around current range
                            low = max(min_v, current - step * 25)
                            high = min(max_v, current + step * 25)
                            value = low
                            while value <= high + 1e-9:
                                values.append(round(value, 6))
                                value += step or 1
                    if not values:
                        values = [current]

                    builder = AlertDialogBuilder(activity)
                    builder.setTitle(defn.title)
                    display = [str(v) for v in values]

                    def on_select(index: int):
                        try:
                            value = values[index]
                        except IndexError:
                            return
                        registry.set(defn.key, value)

                    builder.setItems(display, Callback1(on_select))
                    builder.setNegativeButton("Отмена", None)
                    builder.show()

                return action

            actions.append(make_slider(definition))
        else:
            actions.append(lambda: None)

    builder = AlertDialogBuilder(activity)
    builder.setTitle(title or registry.title)
    builder.setItems(items, Callback1(lambda index: actions[index]() if index < len(actions) else None))
    builder.setNegativeButton("Закрыть", None)
    builder.show()


# === Typed controller helpers =======================================================


if TYPE_CHECKING:  # pragma: no cover - used only for typing assistance
    from org.telegram.tgnet import TLRPC as _TLRPC
    from org.telegram.ui import ActionBar as _ActionBar


def _get_messages_controller():
    controller = get_messages_controller()
    if controller is None:
        raise RuntimeError("MessagesController instance is not available")
    return controller


def _as_input_peer(peer_obj):
    controller = _get_messages_controller()
    get_input_peer = getattr(controller, "getInputPeer", None)
    if callable(get_input_peer):
        return get_input_peer(peer_obj)
    return peer_obj


def resolve_peer(peer_like: Union[str, int, Any]):
    """Resolve peer from id, dialog or username string."""

    controller = _get_messages_controller()

    if peer_like is None:
        return None

    # Already an input peer
    if peer_like.__class__.__name__.startswith("TL_inputPeer"):
        return peer_like

    if hasattr(peer_like, "dialog_id"):
        return _as_input_peer(getattr(peer_like, "dialog_id"))

    if hasattr(peer_like, "id") and not isinstance(peer_like, (str, int)):
        return _as_input_peer(getattr(peer_like, "id"))

    if isinstance(peer_like, int):
        return _as_input_peer(peer_like)

    if isinstance(peer_like, str):
        text = peer_like.strip()
        if not text:
            return None
        if text.isdigit() or (text.startswith("-") and text[1:].isdigit()):
            return _as_input_peer(int(text))
        if text.startswith("-100") and text[1:].isdigit():
            return _as_input_peer(int(text))
        if text.startswith("@"):
            username = text[1:]
            request = TLRPC.TL_contacts_resolveUsername()
            request.username = username
            event = threading.Event()
            resolved = {}

            def callback(response, error):
                try:
                    if error is not None or response is None:
                        resolved["error"] = error
                        return
                    peer = None
                    if getattr(response, "chats", None) and response.chats.size() > 0:
                        chat = response.chats.get(0)
                        peer = controller.getInputPeer(-chat.id if getattr(chat, "megagroup", False) else -chat.id)
                    elif getattr(response, "users", None) and response.users.size() > 0:
                        user = response.users.get(0)
                        peer = controller.getInputPeer(user.id)
                    resolved["peer"] = peer
                finally:
                    event.set()

            send_request(request, callback)
            event.wait(5)
            if "peer" in resolved:
                return resolved["peer"]
            raise RuntimeError(f"Не удалось разрешить пользователя @{username}")
        raise ValueError(f"Unsupported peer identifier: {peer_like}")

    return _as_input_peer(peer_like)


def current_dialog():
    """Return input peer for currently opened dialog if available."""

    fragment = get_last_fragment()
    if fragment is None:
        return None
    dialog_id = None
    if hasattr(fragment, "getDialogId") and callable(getattr(fragment, "getDialogId")):
        try:
            dialog_id = fragment.getDialogId()
        except Exception:
            dialog_id = None
    if dialog_id is None and hasattr(fragment, "getDialogIdLong"):
        try:
            dialog_id = fragment.getDialogIdLong()
        except Exception:
            dialog_id = None
    if dialog_id is None:
        return None
    return resolve_peer(dialog_id)


def pick_dialog(
    identifier: Optional[Union[str, int]] = None,
    *,
    title: str = "Выберите чат",
    on_result: Optional[Callable[[Any], None]] = None,
    allow_manual_input: bool = True,
):
    """Pick dialog by identifier or via simple prompt."""

    if identifier is not None:
        peer = resolve_peer(identifier)
        if on_result:
            on_result(peer)
        return peer

    current = current_dialog()
    if current and not allow_manual_input:
        if on_result:
            on_result(current)
        return current

    activity = get_current_activity()
    if activity is None or not allow_manual_input:
        if on_result:
            on_result(current)
        return current

    builder = AlertDialogBuilder(activity)
    builder.setTitle(title)

    input_view = None
    try:
        EditText = find_class("android.widget.EditText")
        input_view = EditText(activity)
        input_view.setHint("@username или ID")
        builder.setView(input_view)
    except Exception:
        input_view = None

    def _handle_input(_=None):
        text_value = None
        if input_view is not None:
            try:
                text_value = input_view.getText().toString()
            except Exception:
                text_value = None
        if not text_value:
            peer = current
        else:
            try:
                peer = resolve_peer(text_value)
            except Exception as exc:
                bulletin_error = getattr(BulletinHelper, "show_error", None)
                if bulletin_error:
                    bulletin_error(str(exc))
                else:
                    log(f"pick_dialog: {exc}")
                peer = None
        if on_result:
            on_result(peer)

    builder.setPositiveButton("Готово", Callback1(_handle_input))
    builder.setNegativeButton("Отмена", None)
    builder.show()

    return current


def send_text(
    peer: Union[str, int, Any],
    text: str,
    *,
    reply_to: Optional[Union[int, Any]] = None,
    entities: Optional[Iterable[Any]] = None,
    silent: bool = False,
):
    """Send text message to peer using TL request helper."""

    if not isinstance(text, str):
        raise TypeError("text must be a string")

    input_peer = resolve_peer(peer)
    if input_peer is None:
        raise RuntimeError("Не удалось определить получателя")

    req = TLRPC.TL_messages_sendMessage()
    req.peer = input_peer
    req.message = text
    req.random_id = Utilities.random.nextLong()
    if reply_to is not None:
        if isinstance(reply_to, int):
            req.reply_to_msg_id = reply_to
        elif hasattr(reply_to, "id"):
            req.reply_to_msg_id = getattr(reply_to, "id")

    if entities:
        try:
            ArrayList = find_class("java.util.ArrayList")
            java_list = ArrayList()
            for entity in entities:
                java_list.add(entity)
            req.entities = java_list
        except Exception:
            log("send_text: failed to attach entities; sending without them")

    if silent:
        req.silent = True

    send_request(req, lambda *_: None)

    return req.random_id


# === Safe Hook Lifecycle Manager ====================================================


class HookRegistration:
    def __init__(self, plugin: Optional[BasePlugin], method, hook: MethodHook, *, key: str):
        self.plugin = plugin
        self.method = method
        self.hook = hook
        self.key = key
        self.active = True

    def cancel(self):
        if not self.active:
            return
        try:
            unhook = getattr(self.hook, "unhook", None)
            if callable(unhook):
                unhook()
        except Exception:
            log(f"HookRegistration cancel failed for {self.key}: {traceback.format_exc().rstrip()}")
        self.active = False


class HookGroup:
    def __init__(self, name: str = "default"):
        self.name = name
        self._registrations: List[HookRegistration] = []

    def add(self, registration: HookRegistration):
        if registration not in self._registrations:
            self._registrations.append(registration)

    def cancel_all(self):
        for registration in list(self._registrations):
            registration.cancel()
        self._registrations.clear()


class HookLifecycle:
    def __init__(self):
        self._groups: Dict[str, HookGroup] = {}

    def group(self, name: str) -> HookGroup:
        grp = self._groups.get(name)
        if not grp:
            grp = HookGroup(name)
            self._groups[name] = grp
        return grp

    def cancel_all(self):
        for grp in list(self._groups.values()):
            grp.cancel_all()
        self._groups.clear()


_HOOK_REGISTRY: Dict[str, HookRegistration] = {}
_HOOK_REGISTRY_LOCK = threading.RLock()


def _make_hook_key(method) -> str:
    try:
        declaring = method.getDeclaringClass().getName()
    except Exception:
        declaring = str(getattr(method, "__qualname__", method))
    try:
        param_types = [p.getName() for p in method.getParameterTypes()]
    except Exception:
        param_types = []
    return "::".join([declaring, getattr(method, "getName", lambda: str(method))(), ",".join(param_types)])


def _resolve_method(target_class, method_name: str, signature: Optional[Sequence[str]]):
    methods = []
    try:
        methods.extend(list(target_class.getDeclaredMethods()))
    except Exception:
        pass
    try:
        methods.extend(list(target_class.getMethods()))
    except Exception:
        pass
    for method in methods:
        try:
            if method.getName() != method_name:
                continue
            if signature:
                params = [p.getName() for p in method.getParameterTypes()]
                if list(signature) != params:
                    continue
            return method
        except Exception:
            continue
    raise RuntimeError(f"Method {method_name} not found on {target_class}")


def safe_hook(
    plugin: Optional[BasePlugin],
    target: Union[str, Any],
    method_name: str,
    hook: MethodHook,
    *,
    signature: Optional[Sequence[str]] = None,
    group: Optional[HookGroup] = None,
    once: bool = True,
):
    if isinstance(target, str):
        target_class = find_class(target)
    else:
        target_class = target
    method = _resolve_method(target_class, method_name, signature)
    key = _make_hook_key(method)
    with _HOOK_REGISTRY_LOCK:
        existing = _HOOK_REGISTRY.get(key)
        if once and existing and existing.active:
            log(f"safe_hook: hook already registered for {key}")
            if group and existing not in group._registrations:
                group.add(existing)
            return existing

    if plugin is not None:
        try:
            plugin.hook_method(method, hook)
        except Exception:
            log(f"safe_hook: failed to hook {key}: {traceback.format_exc().rstrip()}")
            raise
    else:
        try:
            hook.hook_method(method)
        except Exception:
            log(f"safe_hook: failed to hook (no plugin) {key}: {traceback.format_exc().rstrip()}")
            raise

    registration = HookRegistration(plugin, method, hook, key=key)
    if group:
        group.add(registration)
    with _HOOK_REGISTRY_LOCK:
        _HOOK_REGISTRY[key] = registration
    return registration


def safe_unhook_all():
    with _HOOK_REGISTRY_LOCK:
        registrations = list(_HOOK_REGISTRY.values())
        _HOOK_REGISTRY.clear()
    for registration in registrations:
        registration.cancel()


# === Debounce & Rate limit utilities ================================================


def debounce(wait_seconds: float, *, leading: bool = False):
    """Decorator to debounce function calls."""

    def decorator(func):
        lock = threading.RLock()
        state = {"timer": None}

        @wraps(func)
        def wrapper(*args, **kwargs):
            def run():
                with lock:
                    state["timer"] = None
                if not leading:
                    func(*args, **kwargs)

            with lock:
                timer = state.get("timer")
                if timer is not None:
                    timer.cancel()
                elif leading:
                    func(*args, **kwargs)
                timer = threading.Timer(wait_seconds, run)
                timer.daemon = True
                state["timer"] = timer
                timer.start()

        return wrapper

    return decorator


def throttle(interval: float):
    """Decorator to throttle function execution to once per interval."""

    def decorator(func):
        lock = threading.RLock()
        state = {"last": 0.0, "scheduled": False, "args": None, "kwargs": None}

        @wraps(func)
        def wrapper(*args, **kwargs):
            now = time.time()
            with lock:
                if now - state["last"] >= interval:
                    state["last"] = now
                    func(*args, **kwargs)
                    return
                state["args"] = args
                state["kwargs"] = kwargs
                if state["scheduled"]:
                    return
                delay = interval - (now - state["last"])
                state["scheduled"] = True

            def run():
                with lock:
                    state["scheduled"] = False
                    state["last"] = time.time()
                    args_, kwargs_ = state["args"], state["kwargs"]
                func(*args_, **kwargs_)

            timer = threading.Timer(delay, run)
            timer.daemon = True
            timer.start()

        return wrapper

    return decorator


class RateLimiter:
    def __init__(self, rate: int, per_seconds: float):
        if rate <= 0:
            raise ValueError("rate must be positive")
        self.rate = rate
        self.per_seconds = float(per_seconds)
        self._timestamps = deque(maxlen=rate)
        self._lock = threading.RLock()

    def acquire(self):
        with self._lock:
            now = time.time()
            if len(self._timestamps) < self.rate:
                self._timestamps.append(now)
                return 0.0
            oldest = self._timestamps[0]
            wait = oldest + self.per_seconds - now
            if wait <= 0:
                self._timestamps.append(now)
                return 0.0
            self._timestamps.append(now + wait)
            return max(0.0, wait)

    def run(self, func: Callable, *args, **kwargs):
        wait_time = self.acquire()
        if wait_time > 0:
            time.sleep(wait_time)
        return func(*args, **kwargs)


def priority_queue_worker():
    """Create a background worker that processes queued callables with priorities."""

    task_queue: "queue.PriorityQueue[Tuple[int, int, Callable[[], None]]]" = queue.PriorityQueue()
    counter = itertools.count()

    def submit(callback: Callable[[], None], *, priority: int = 10):
        task_queue.put((priority, next(counter), callback))

    def worker():
        while True:
            try:
                priority, _, callback = task_queue.get()
            except Exception:
                continue
            try:
                callback()
            except Exception:
                log(f"priority_queue_worker: task error: {traceback.format_exc().rstrip()}")
            finally:
                task_queue.task_done()

    thread = threading.Thread(target=worker, daemon=True)
    thread.start()
    return submit


# === Markdown helpers ===============================================================


_MARKDOWN_TOKENS = {
    "**": "bold",
    "__": "underline",
    "~~": "strikethrough",
    "``": "code",
    "`": "code",
}


def _extract_links(text: str) -> Tuple[str, List[Dict[str, Any]]]:
    import re

    pattern = re.compile(r"\\[([^\\]]+)\\]\\(([^\\)]+)\\)")
    entities: List[Dict[str, Any]] = []
    plain_parts: List[str] = []
    last = 0
    for match in pattern.finditer(text):
        plain_parts.append(text[last : match.start()])
        label = match.group(1)
        url = match.group(2)
        start = len("".join(plain_parts))
        plain_parts.append(label)
        end = len("".join(plain_parts))
        entities.append({"type": "text_url", "start": start, "end": end, "url": url})
        last = match.end()
    plain_parts.append(text[last:])
    return "".join(plain_parts), entities


def _parse_inline_entities(text: str) -> Tuple[str, List[Dict[str, Any]]]:
    plain_chars: List[str] = []
    entities: List[Dict[str, Any]] = []
    stacks: Dict[str, List[int]] = {token: [] for token in _MARKDOWN_TOKENS}

    i = 0
    length = len(text)
    while i < length:
        matched = False
        for token, entity_type in _MARKDOWN_TOKENS.items():
            if not text.startswith(token, i):
                continue
            closing_index = text.find(token, i + len(token))
            if closing_index == -1:
                continue
            stack = stacks[token]
            if stack:
                start = stack.pop()
                end = len(plain_chars)
                if end > start:
                    entities.append({"type": entity_type, "start": start, "end": end})
            else:
                stack.append(len(plain_chars))
            i += len(token)
            matched = True
            break
        if matched:
            continue
        plain_chars.append(text[i])
        i += 1

    # Append unmatched tokens as literal characters
    for token, stack in stacks.items():
        while stack:
            pos = stack.pop()
            plain_chars.insert(pos, token)

    return "".join(plain_chars), entities


def _utf16_index(text: str, index: int) -> int:
    return len(text[:index].encode("utf-16-le")) // 2


def _convert_entities(plain_text: str, entities_meta: List[Dict[str, Any]]):
    result = []
    for meta in entities_meta:
        start = _utf16_index(plain_text, meta["start"])
        end = _utf16_index(plain_text, meta["end"])
        length = max(0, end - start)
        if length <= 0:
            continue
        entity_type = meta["type"]
        try:
            if entity_type == "bold":
                entity = TLRPC.TL_messageEntityBold()
            elif entity_type == "underline":
                entity = TLRPC.TL_messageEntityUnderline()
            elif entity_type == "strikethrough":
                entity = TLRPC.TL_messageEntityStrike()
            elif entity_type == "code":
                entity = TLRPC.TL_messageEntityCode()
            elif entity_type == "text_url":
                entity = TLRPC.TL_messageEntityTextUrl()
                entity.url = meta.get("url", "")
            else:
                continue
        except Exception:
            continue
        entity.offset = start
        entity.length = length
        result.append(entity)
    return result


def md(text: str) -> Tuple[str, List[Any]]:
    """Parse simplified markdown string to Telegram text + entities."""

    plain, entities = _extract_links(text)
    plain, inline_entities = _parse_inline_entities(plain)
    entities.extend(inline_entities)
    tl_entities = _convert_entities(plain, entities)
    return plain, tl_entities


def split_text(text: str, *, limit: int = 4096) -> List[str]:
    if limit <= 0:
        raise ValueError("limit must be positive")
    parts: List[str] = []
    current: List[str] = []
    current_len = 0

    def flush():
        nonlocal current, current_len
        if current:
            parts.append("".join(current))
            current = []
            current_len = 0

    for segment in text.splitlines(True):
        segment_len = len(segment)
        while segment_len > 0:
            available = limit - current_len
            if available <= 0:
                flush()
                available = limit
            if segment_len <= available:
                current.append(segment)
                current_len += segment_len
                segment_len = 0
            else:
                split_at = segment.rfind(" ", 0, available)
                if split_at <= 0:
                    split_at = available
                current.append(segment[:split_at])
                current_len += split_at
                flush()
                segment = segment[split_at:]
                segment_len = len(segment)
    flush()
    return parts


# === Media helpers ==================================================================


def _ensure_path(path) -> str:
    return str(path) if path is not None else ""


def download_media(message, *, blocking: bool = False, priority: int = FileLoader.PRIORITY_NORMAL) -> Optional[str]:
    """Download media from message and return local path."""

    if message is None:
        return None
    media = getattr(message, "media", None)
    if media is None:
        return None
    document = getattr(media, "document", None)
    if document is None and hasattr(media, "getDocument"):
        document = media.getDocument()
    if document is None:
        return None

    loader = get_file_loader()
    path = loader.getPathToAttach(document, True)
    if path.exists():
        return _ensure_path(path)

    try:
        loader.loadFile(document, "altylib_media", priority, 1)
    except Exception:
        log(f"download_media failed: {traceback.format_exc().rstrip()}")
        return None

    if blocking:
        for _ in range(100):
            if path.exists():
                break
            time.sleep(0.1)

    return _ensure_path(path)


def save_to_gallery(path: str):
    if not path:
        raise ValueError("path is required")
    if not os.path.exists(path):
        raise FileNotFoundError(path)
    try:
        Utilities.addMediaToGallery(path)
    except Exception:
        try:
            MediaController = find_class("org.telegram.messenger.MediaController")
            MediaController.saveFile(path, False)
        except Exception:
            log(f"save_to_gallery failed: {traceback.format_exc().rstrip()}")


def with_image(path: str, fn: Callable[[Image.Image], Any]):
    if not callable(fn):
        raise ValueError("fn must be callable")
    if not os.path.exists(path):
        raise FileNotFoundError(path)
    img = Image.open(path)
    try:
        result = fn(img)
        if isinstance(result, Image.Image):
            result.save(path)
        return result
    finally:
        img.close()


# === UI helpers =====================================================================


def _bulletin_call(name: str, message: str):
    fn = getattr(BulletinHelper, name, None)
    if callable(fn):
        fn(message)
    else:
        log(f"Bulletin {name} unavailable: {message}")


def snackbar_info(message: str):
    _bulletin_call("show_info", message)


def snackbar_warn(message: str):
    _bulletin_call("show_warning", message)


def snackbar_error(message: str):
    _bulletin_call("show_error", message)


def snackbar_undo(message: str, *, on_undo: Optional[Callable[[], None]] = None):
    activity = get_current_activity()
    if activity is None:
        snackbar_info(message)
        return
    builder = AlertDialogBuilder(activity)
    builder.setTitle("Отмена действия")
    builder.setMessage(message)
    if on_undo:
        builder.setPositiveButton("Отменить", Callback1(lambda _: on_undo()))
    builder.setNegativeButton("Закрыть", None)
    builder.show()


def quick_list_pick(
    options: Sequence[Union[str, Tuple[str, Any]]],
    *,
    title: str = "Выберите", 
    on_select: Optional[Callable[[Any], None]] = None,
    cancel_text: str = "Отмена",
):
    activity = get_current_activity()
    if activity is None:
        raise RuntimeError("Нет активного окна для отображения списка")
    entries: List[str] = []
    mapping: List[Any] = []
    for opt in options:
        if isinstance(opt, tuple):
            entries.append(str(opt[0]))
            mapping.append(opt[1])
        else:
            entries.append(str(opt))
            mapping.append(opt)

    builder = AlertDialogBuilder(activity)
    builder.setTitle(title)

    def handle(index: int):
        if 0 <= index < len(mapping) and on_select:
            on_select(mapping[index])

    builder.setItems(entries, Callback1(handle))
    builder.setNegativeButton(cancel_text, None)
    builder.show()


def show_bottom_sheet(
    options: Sequence[Union[str, Tuple[str, Any]]],
    *,
    title: str = "Действия",
    on_select: Optional[Callable[[Any], None]] = None,
):
    activity = get_current_activity()
    if activity is None:
        raise RuntimeError("Нет активного окна для отображения меню")
    builder = AlertDialogBuilder(activity)
    builder.setTitle(title)
    try:
        builder.setUseBottomSheet(True)
    except Exception:
        pass
    entries: List[Tuple[str, Any]] = []
    for opt in options:
        if isinstance(opt, tuple):
            entries.append((str(opt[0]), opt[1]))
        else:
            entries.append((str(opt), opt))

    def handle(index: int):
        if 0 <= index < len(entries) and on_select:
            on_select(entries[index][1])

    builder.setItems([e[0] for e in entries], Callback1(handle))
    builder.setNegativeButton("Закрыть", None)
    builder.show()


def copy_to_clipboard(text: str, label: str = "AltyLib"):
    try:
        Utilities.copyToClipboard(text)
        snackbar_info(f"Скопировано: {label}")
    except Exception:
        log(f"copy_to_clipboard failed: {traceback.format_exc().rstrip()}")


# === Notification observers =========================================================


_NOTIFICATION_LOCK = threading.RLock()
_NOTIFICATION_OBSERVERS: List[Tuple[Any, Any, int]] = []


def _notification_delegate_base():
    NotificationCenter = find_class("org.telegram.messenger.NotificationCenter")
    return NotificationCenter


def _make_delegate(event_id: int, callback: Callable[[int, Any], None]):
    NotificationCenter = _notification_delegate_base()
    Delegate = NotificationCenter.NotificationCenterDelegate

    class Observer(dynamic_proxy(Delegate)):
        def __init__(self, cb):
            super().__init__()
            self.cb = cb

        def didReceivedNotification(self, event, account, args):  # type: ignore[override]
            if event == event_id:
                try:
                    self.cb(account, args)
                except Exception:
                    log(f"Notification observer error: {traceback.format_exc().rstrip()}")

    return Observer(callback)


def _clear_notification_observers():
    with _NOTIFICATION_LOCK:
        for center, delegate, event_id in list(_NOTIFICATION_OBSERVERS):
            try:
                center.removeObserver(delegate, event_id)
            except Exception:
                pass
        _NOTIFICATION_OBSERVERS.clear()


atexit.register(_clear_notification_observers)


def on(event_name: str, *, account: int = 0):
    """Decorator registering NotificationCenter observer."""

    def decorator(func: Callable[[Any], None]):
        NotificationCenter = _notification_delegate_base()
        event_id = getattr(NotificationCenter, event_name, None)
        if event_id is None:
            raise ValueError(f"NotificationCenter has no event '{event_name}'")
        center = NotificationCenter.getInstance(account)
        params = list(inspect.signature(func).parameters.values())
        if len(params) >= 2:
            delegate = _make_delegate(event_id, lambda acc, args: func(acc, args))
        else:
            delegate = _make_delegate(event_id, lambda acc, args: func(args))
        try:
            center.addObserver(delegate, event_id)
        except Exception:
            log(f"Failed to add observer for {event_name}: {traceback.format_exc().rstrip()}")
            raise
        with _NOTIFICATION_LOCK:
            _NOTIFICATION_OBSERVERS.append((center, delegate, event_id))
        return func

    return decorator


# === CLI Helpers ====================================================================


PLUGIN_TEMPLATE = (
    '"""Plugin generated by AltyLib CLI"""\n\n'
    '__name__ = "{name}"\n'
    '__id__ = "{plugin_id}"\n'
    '__version__ = "0.1.0"\n'
    '__author__ = "{author}"\n'
    '__min_version__ = "11.9.1"\n'
)


def init_plugin_scaffold(path: str, *, plugin_id: Optional[str] = None, author: str = "@user") -> str:
    plugin_id = plugin_id or f"plugin_{int(time.time())}"
    name = plugin_id.replace("_", " ").title()
    os.makedirs(path, exist_ok=True)
    plugin_path = os.path.join(path, f"{plugin_id}.plugin")
    if os.path.exists(plugin_path):
        raise FileExistsError(plugin_path)
    with open(plugin_path, "w", encoding="utf-8") as fp:
        fp.write(PLUGIN_TEMPLATE.format(name=name, plugin_id=plugin_id, author=author))
    return plugin_path


def validate_plugin_manifest(path: str) -> Dict[str, Any]:
    if not os.path.exists(path):
        raise FileNotFoundError(path)
    with open(path, "r", encoding="utf-8") as fp:
        content = fp.read()
    required = ["__id__", "__version__", "__min_version__"]
    missing = [key for key in required if key not in content]
    if missing:
        raise ValueError(f"Missing required fields: {', '.join(missing)}")
    return {"path": path, "size": len(content)}


def altylib_cli(argv: Optional[Sequence[str]] = None):
    parser = argparse.ArgumentParser(prog="altylib", description="AltyLib helper CLI")
    sub = parser.add_subparsers(dest="command")

    init_parser = sub.add_parser("init", help="Create plugin scaffold")
    init_parser.add_argument("path", help="Directory for new plugin")
    init_parser.add_argument("--id", dest="plugin_id", help="Plugin identifier")
    init_parser.add_argument("--author", default="@user", help="Author mention")

    val_parser = sub.add_parser("validate", help="Validate plugin manifest")
    val_parser.add_argument("file", help="Plugin file to check")

    args = parser.parse_args(list(argv) if argv is not None else None)

    if args.command == "init":
        result = init_plugin_scaffold(args.path, plugin_id=args.plugin_id, author=args.author)
        print(f"Created plugin scaffold at {result}")
        return result
    if args.command == "validate":
        info = validate_plugin_manifest(args.file)
        print(f"Plugin manifest OK: {info['path']} ({info['size']} bytes)")
        return info
    parser.print_help()
    return None


# === Crash diagnostics ==============================================================


class CrashReporter:
    def __init__(self, log_file: Optional[str] = None):
        self.log_file = log_file or os.path.join(JsonCacheFile.cache_dir_name, "altylib_crash.log")
        self.enabled = False
        self._old_hook = None

    def _write(self, message: str):
        os.makedirs(os.path.dirname(self.log_file), exist_ok=True)
        with open(self.log_file, "a", encoding="utf-8") as fp:
            fp.write(f"[{datetime.utcnow().isoformat()}] {message}\n")

    def _handle(self, exc_type, exc, tb):
        message = "".join(traceback.format_exception(exc_type, exc, tb))
        self._write(message)
        snackbar_error("Произошла ошибка, сохранен отчёт")
        if self._old_hook:
            self._old_hook(exc_type, exc, tb)

    def enable(self):
        if self.enabled:
            return
        import sys

        self._old_hook = sys.excepthook
        sys.excepthook = self._handle
        self.enabled = True

    def disable(self):
        if not self.enabled:
            return
        import sys

        if self._old_hook:
            sys.excepthook = self._old_hook
        self.enabled = False


_CRASH_REPORTER: Optional[CrashReporter] = None


def install_crash_reporter(log_file: Optional[str] = None) -> CrashReporter:
    global _CRASH_REPORTER
    if _CRASH_REPORTER is None:
        _CRASH_REPORTER = CrashReporter(log_file)
    _CRASH_REPORTER.enable()
    return _CRASH_REPORTER


# === Hot reload & debug helpers =====================================================


_HOT_RELOAD_TARGETS: set = set()


def enable_hot_reload(*module_names: str):
    if not module_names:
        module_names = (__name__,)
    _HOT_RELOAD_TARGETS.update(module_names)


def reload_current_plugin(*module_names: str):
    import importlib
    import sys

    targets = module_names or tuple(_HOT_RELOAD_TARGETS) or (__name__,)
    reloaded = []
    for module_name in targets:
        module = sys.modules.get(module_name)
        if not module:
            continue
        reloaded.append(importlib.reload(module))
    snackbar_info("Модули перезагружены")
    return reloaded


# === Feature compatibility helpers ==================================================


_FEATURE_ADAPTERS: Dict[str, Callable[[], bool]] = {}
_FEATURE_CACHE: Dict[str, bool] = {}


def features_register(name: str, detector: Callable[[], bool]):
    _FEATURE_ADAPTERS[name] = detector
    _FEATURE_CACHE.pop(name, None)


def features_has(name: str) -> bool:
    if name in _FEATURE_CACHE:
        return _FEATURE_CACHE[name]
    detector = _FEATURE_ADAPTERS.get(name)
    if not detector:
        return False
    try:
        value = bool(detector())
    except Exception:
        log(f"features_has: detector for {name} failed: {traceback.format_exc().rstrip()}")
        value = False
    _FEATURE_CACHE[name] = value
    return value


def features_clear_cache(name: Optional[str] = None):
    if name:
        _FEATURE_CACHE.pop(name, None)
    else:
        _FEATURE_CACHE.clear()


# === Cookbook =======================================================================


_COOKBOOK: Dict[str, Dict[str, Any]] = {
    "auto_responder": {
        "title": "Автоответчик",
        "description": "Автоматически отвечает на входящие сообщения по шаблону.",
        "steps": [
            "Используйте on('didReceiveNewMessages') для получения уведомлений",
            "Проверяйте текст сообщения и отвечайте через send_text",
            "Настройте шаблон через SettingsRegistry.switch/list",
        ],
    },
    "media_autosave": {
        "title": "Автосохранение медиа",
        "description": "Скачивает медиа из выбранных чатов в галерею.",
        "steps": [
            "Подпишитесь на события didReceiveNewMessages",
            "Используйте download_media и save_to_gallery",
            "Ограничьте скорость через RateLimiter",
        ],
    },
    "quick_translate": {
        "title": "Быстрый перевод",
        "description": "Перевод текста по команде .translate",
        "steps": [
            "Зарегистрируйте команду через register_command",
            "Вызывайте внешний API и кешируйте результаты в TTLCache",
            "Отправляйте ответ через send_text",
        ],
    },
}


def list_recipes() -> Dict[str, str]:
    return {key: value["description"] for key, value in _COOKBOOK.items()}


def load_recipe(name: str) -> Dict[str, Any]:
    recipe = _COOKBOOK.get(name)
    if not recipe:
        raise KeyError(name)
    return recipe
